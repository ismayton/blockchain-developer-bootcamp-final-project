# Discussion of Smart Contract Design Pattern Decisions

### Inheritance

The HornMarketplace NFT contract makes use of two libraries that provide secure and audited solutions to problems that arise when handling the exchange of real-world backed NFTs.
###### OpenZeppelin Counters.sol
The first is OpenZeppelin's Counters.sol utility contract, which provides a very simple and very secure counter functionality that can only be incremented, decremented, or returned. I used this contract to prevent any enumeration, overflow, or repetition of the Horn NFT tokenId, in this case called hornId. This is an especially useful solution as it is paramount that malicious actors not be able to manipulate or duplicate tokenIds.
###### OpenZeppelin Escrow.sol
The second is OpenZeppelin's Escrow.sol contract, which is a standalone instantiated contract that handles the reception and release of ETH in an escrow structure. This facilitates the trustless exchange of the Horn NFTs which represent valuable ($4000-$20000!) real-world assets, in this case musical instruments. The escrow contract features functions internal to the Marketplace and is never called directly by users as it inherits OpenZeppelin's Ownable.sol contract and is therefore explicitly owned and interacted with only by the Marketplace contract. This prevents any sort of logic attack vectors that would be an issue for an escrow contract with functions freely callable by malicious actors. I had to change a few functions within this contract to fix some bugs that arose around using the escrow in a marketplace setting, as the original implementation was created to facilitate one exchange at a time between single parties. A simple change to the recordkeeping of _deposits and the math under the withdraw function sufficed to customize it to work for multiple addresses and NFTs more broadly.

### Access Control

The HornMarketplace NFT contract makes use of unconventional access control, namely to restrict certain functions calls to only the currentOwners, sellers, and buyers of Horn NFTs. This was implemented to ascertain both the shipping/delivering process and the interactions between the marketplace contract and its instantiated escrow contract, which handles the payment for a Horn NFT. For example, only the currentOwner of a minted Horn NFT may list it for sale, only the Seller of a Horn NFT may mark it as Shipped (which also approves the Buyer address), and only the Buyer of a specific Horn NFT may mark it as delivered and finalize the transfer of the NFT (completing the approval which was given at shipping time). These access modifiers provide a reliable, trustless framework for the uncertain process of listing, selling, shipping, and receiving an expensive instrument across the internet and real world.

### Bonus: Inter-Contract Execution via testing
Because I wrote the vast majority of my test functions in Solidity and not in Javascript (to delve as deep into the language as possible over the course of the bootcamp), I also made use of inter-contract execution as a design pattern in order to simulate the behavior of EOA (end users) who acted as buyers and sellers of the Horn NFT during the transfer process. My main test contract instantiates a separate, standalone Buyer and Seller contract which call the HornMarketplace's functions in various orders to prove the functionality of the marketplace and behave as an end user or external contract might, both legitimately and maliciously. This was a very fun project and future endeavors will definitely include learning the intricacies of the EVM, assembly, and low-level calls in Solidity in combination with the abi encoding options.
